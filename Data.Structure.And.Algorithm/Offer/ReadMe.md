# 算法大部分都是《剑指Offer》中的编程题目

 ![](https://img.shields.io/badge/license-MIT_License-blue.svg)  ![](https://img.shields.io/badge/language-@java-green.svg)    ![](https://img.shields.io/badge/version-@1.0-blue.svg)  ![](https://img.shields.io/badge/authod-@simon-red.svg)  [![](https://img.shields.io/badge/blog-@simon-yellow.svg)](http://simoncode.top)



* 1.有序二维数组的查找 **QueryTwoArray**
* 2.空格替换 **ReplaceSpace**
* 3.输入一个链表，从尾到头打印链表每个节点的值 **PrintListFromTailToHead**
* 4.重建二叉树 **ReConstructBinaryTree**
* 5.使用两个栈模拟队列 **StackToQueue**
* 6.旋转数组中的最小数字 **MinNumberInRotateArray**
* 7.斐波拉契算法的更优解法 **Fibonacci**
* 8.求二进制中的1的个数 **NumberOf1**
* 9.将技术和偶数区分开 **Reorder**
* 10.查找链表中倒数k的值 **FindKthToTail**
* 11.合并两个递增的有序链表 **Merge**
* 12.判断一个树是不是一个的子树 **HasSubtree**
* 13.二叉树的镜像 **MirrorRecursively**
* 14.顺时针打印一个矩阵 **PrintMatrixClockwisely**
* 15.包含min函数的栈 **StackWithMin**
* 16.栈的压入，弹出序列 **IsPopOrder**
* 17.从上往下打印二叉树 **PrintFromTopToBottom**
* 18.二叉搜索树的后序遍历 **VerifySquenceOfBST**
* 19.超过数组一半的数字 **MoreThanHalfNum**
* 20.找到最大的目的数组 **FindGreatesSumOfSubArray**
* 21.出现1的次数 **NumberOf1BetWeenAndN**
* 22.整数的N次方 **Power**
* 23.打印可拼接的最小数 **PrintMinNumber**
* 24.获得最小的k个数 **GetLeastNumbers**
* 25.找到两个链表的公共节点 **FindFirstCommonNode**
* 26.递增数组中和为S的两个数 **FindNumbersWithSum**
* 27.和为S的所有连续整数 **FindContinuousSequence**
* 28.翻转一个字符串中的所有字符 **ReverseSentence**
* 29.左移一个字符串 **LeftRotateString**
* 30.求n个骰子出现的值的概率 **PrintProbability**
* 31.机器人运动范围 **MovingCount**
* 32.求一个窗口中的最大值 **MaxInWindows**
* 33.二叉树的序列化和反序列化 **SerializeAndDeserialize**
* 34.按层打印二叉树 **PrintTreeByTier**
